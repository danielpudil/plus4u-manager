import React from 'react';
import createReactClass from 'create-react-class';
import PropTypes from 'prop-types';
import * as UU5 from "uu5g04";
import ns from "./bricks-ns.js";

import Backdrop from './backdrop.js';
import './slider.less';
import SliderItem from './slider-item.js';

export const Slider = createReactClass({

  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.PureRenderMixin, UU5.Common.ElementaryMixin, UU5.Common.ContentMixin, UU5.Common.ColorSchemaMixin, UU5.Common.NestingLevelMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: ns.name("Slider"),
    nestingLevelList: UU5.Environment.getNestingLevelList('bigBoxCollection', 'box'),
    classNames: {
      main: ns.css("slider"),
      vertical: ns.css("slider-vertical"),
      track: ns.css("slider-track"),
      selection: ns.css("slider-selection"),
      pointer: ns.css("slider-pointer"),
      active: ns.css("slider-active"),
      size: ns.css("slider-size-")
    },
    defaults: {
      childTagName: 'UU5.Bricks.Slider.Item'
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    vertical: PropTypes.bool,
    min: PropTypes.number,
    max: PropTypes.number,
    step: PropTypes.number,
    value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),
    onChange: PropTypes.func,
    onChanged: PropTypes.func,
    size: PropTypes.oneOf(['s', 'm', 'l', 'xl']),
    allowTags: PropTypes.array
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      vertical: false,
      min: 0,
      max: 10,
      step: 1,
      onChange: null,
      onChanged: null,
      size: 'm',
      allowTags: [],
      value: null // default: min
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    this._pointers = [];

    return {
      active: false,
      activePointer: null
    };
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      this.setValue(nextProps.value);
    }
  },

  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  getPointers() {
    return this._pointers;
  },

  getValue() {
    let values = this._pointers.map(item => item.getValue());
    if (values.length === 0) values = this.props.min;else if (values.length === 1) values = values[0];

    return values;
  },

  setValue(value, setStateCallback) {
    let values = this._getValueArray(value);

    values.forEach((item, i) => {
      this._pointers[i] && this._pointers[i].setValue(item, setStateCallback);
    });

    return this;
  },

  increase(value, setStateCallback) {
    let values = this._getValueArray(value);

    values.forEach((item, i) => {
      this._pointers[i] && this._pointers[i].increase(item, setStateCallback);
    });

    return this;
  },

  decrease(value, setStateCallback) {
    let values = this._getValueArray(value);

    values.forEach((item, i) => {
      this._pointers[i] && this._pointers[i].decrease(item, setStateCallback);
    });

    return this;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  expandChildProps_(child, childIndex) {
    const newChildProps = UU5.Common.Tools.mergeDeep({}, child.props);
    newChildProps.name = newChildProps.name || (this.props.name ? this.props.name + "-" + childIndex : null);
    newChildProps.disabled = newChildProps.disabled || this.isDisabled();
    newChildProps._min = this.props.min;
    newChildProps._max = this.props.max;
    newChildProps._step = this.props.step;
    newChildProps._checkValue = this._checkValue;
    newChildProps._getStyle = this._getStyle;

    if (newChildProps.value === null) {
      const value = this._getValueArray();
      newChildProps.value = value[childIndex];
    }

    let ref = newChildProps.ref_;
    newChildProps.ref_ = item => {
      this._pointers.push(item);
      typeof ref === "function" && ref(item);
    };

    return newChildProps;
  },

  shouldChildRender_(child) {
    const childTagName = UU5.Common.Tools.getChildTagName(child);
    const childTagNames = this.props.allowTags.concat(this.getDefault().childTagName);
    return childTagNames.indexOf(childTagName) > -1;
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getValueArray(value) {
    value === undefined && (value = this.props.value);
    return Array.isArray(value) ? value.slice(0, 2) : [value];
  },

  _checkValue(value) {
    if (value === null) {
      value = this.props.min;
    } else {
      value = Math.round(value / this.props.step) * this.props.step;

      if (value < this.props.min) {
        value = this.props.min;
      } else if (value > this.props.max) {
        value = this.props.max;
      }
    }

    return value;
  },

  _prepareIfcValue(value, nearestPointer) {
    const values = this._pointers.map(item => item === nearestPointer ? value : item.getValue());

    return values.length === 1 ? values[0] : values;
  },

  _changeValue(value, e) {
    if (this.state.nearestPointer.getValue() !== value) {
      const values = this._prepareIfcValue(value, this.state.nearestPointer);

      let onChange = this._getOnChange(values, e);
      let onChanged;
      !onChange && (onChanged = this._getOnChanged(values, e));

      onChange ? onChange(this) : this.state.nearestPointer.setValue(value, onChanged);
    }

    return this;
  },

  _activate(e) {
    let value = this._countValue(e),
        onChange,
        onChanged;
    const nearestPointer = this._getNearestPointer(value);

    if (this.getValue() !== value) {
      const values = this._prepareIfcValue(value, nearestPointer);
      onChange = this._getOnChange(values, e);
      !onChange && (onChanged = this._getOnChanged(values, e));
    }

    nearestPointer.setValue(value);

    this.setState({
      active: true,
      nearestPointer: nearestPointer
    }, onChange || onChanged ? () => onChange ? onChange(this) : onChanged(this) : null);
    return this;
  },

  _deactivate(e) {
    this.setState({ active: false, nearestPointer: null });
    return this;
  },

  _isActive() {
    return this.state.active;
  },

  _move(e) {
    if (this._isActive()) {
      this._changeValue(this._countValue(e), e);
    }
    return this;
  },

  _getOnChange(value, e) {
    let onChange;
    if (typeof this.props.onChange === 'function') {
      onChange = () => {
        this.props.onChange({ value: value, component: this, event: e });
      };
    }
    return onChange;
  },

  _getOnChanged(value, e) {
    let onChanged;
    if (typeof this.props.onChanged === 'function') {
      onChanged = () => {
        this.props.onChanged({ value: value, component: this, event: e });
      };
    }
    return onChanged;
  },

  _getStartPositions() {
    let el = this._track;
    let xPos = 0;
    let yPos = -1 * window.pageYOffset;

    while (el) {
      xPos += el.offsetLeft - el.scrollLeft + el.clientLeft;
      yPos += el.offsetTop;
      el = el.offsetParent;
    }

    return { x: xPos, y: yPos };
  },

  _countValue(e) {
    const sliderStart = this.props.vertical ? this._getStartPositions().y : this._getStartPositions().x;
    let actualPosition = this.props.vertical ? e.clientY : e.clientX;
    if (e.touches) {
      actualPosition = this.props.vertical ? e.touches.item(0).clientY : e.touches.item(0).clientX;
    }

    const absolutePosition = actualPosition - sliderStart;
    const end = this.props.vertical ? this._track.offsetHeight : this._track.offsetWidth;

    const min = this.props.min;
    const max = this.props.max;
    const step = this.props.step;

    const absoluteMax = max - min;

    const realValue = absolutePosition / (end / absoluteMax);
    let value = min + Math.round(realValue / step) * step;

    this.props.vertical && (value = this.props.max + this.props.min - value);
    value > this.props.max && (value = this.props.max);
    value < this.props.min && (value = this.props.min);

    return value;
  },

  _getMainAttrs() {
    const attrs = this.getMainAttrs();

    attrs.className += ' ' + this.getClassName('size') + this.props.size;
    this.props.vertical && (attrs.className += ' ' + this.getClassName('vertical'));

    if (!this.isDisabled()) {
      this._isActive() && (attrs.className += ' ' + this.getClassName().active);

      attrs.onMouseDown = this._activate;
      attrs.onMouseMove = this._move;
      attrs.onMouseUp = this._deactivate;
      attrs.onTouchStart = this._activate;
      attrs.onTouchMove = e => {
        e.preventDefault();
        this._move(e);
      };
      attrs.onTouchEnd = this._deactivate;
      attrs.onMouseLeave = this._deactivate;
    }

    return attrs;
  },

  _getBackdropProps() {
    let backdropId = this.getId() + "-backdrop";

    return {
      hidden: !this._isActive(),
      id: backdropId,
      onClick: (backdrop, event) => event.target.id === backdropId && this._deactivate(),
      mainAttrs: {
        onMouseUp: this._deactivate,
        onTouchEnd: this._deactivate
      }
    };
  },

  _getStyle(value) {
    const size = (this._checkValue(value) - this.props.min) / (this.props.max - this.props.min) * 100 + '%';
    return this.props.vertical ? { height: size } : { width: size };
  },

  _getNearestPointer(newValue) {
    let min = Infinity,
        nearestPointer;
    this._pointers.forEach(item => {
      const value = Math.abs(newValue - item.getValue());

      if (min > value) {
        min = value;
        nearestPointer = item;
      }
    });

    return nearestPointer;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    let pointers = this.getChildren();

    if (!pointers || pointers.length === 0) {
      const values = this._getValueArray();
      pointers = this.buildChildren({
        children: values.map(value => <SliderItem value={value} />)
      });
    } else if (pointers && pointers.length > 2) {
      pointers = pointers.slice(0, 2);
    }

    return this.getNestingLevel() ? <div {...this._getMainAttrs()}>
            <Backdrop {...this._getBackdropProps()} />
            <div className={this.getClassName('track')} ref={item => this._track = item}>
              {pointers}
            </div>
          </div> : null;
  }
  //@@viewOff:render
});

Slider.Item = SliderItem;

export default Slider;